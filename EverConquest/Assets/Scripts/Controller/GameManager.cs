/**
 * This class is a Game manager which will manage the events generated by other controllers in the game.
 * This is designed in accordance to the MVC pattern.
 * 
**/

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class GameManager : MonoBehaviour {
	
	[SerializeField] private Map m_map;
	[SerializeField] private MouseController m_mouseController;

	HashSet<Tile> neighbours;
	Creature pawn_piece;

	void OnEnable() {
		MouseController.OnClicked += OnHexSelected;
		MouseController.SelectMove += OnMoveSelected;
	}

	void OnDisable() {
		MouseController.OnClicked -= OnHexSelected;
		MouseController.SelectMove -= OnMoveSelected;
	}


	// Handles a onclick event generated by mouse control script when player click on top of a hex tile
	// will color a set of neighbour tiles for now.
	void OnHexSelected(Tile tl) {
		if (tl.Owner == null) {
			HexReset ();
			GameObject tile = GameObject.Find ("Hex (" + tl.XCoord + "," + tl.YCoord + ")");
			if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color == Color.white)
				tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.blue;
			else {
				tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.white;
			}

		} else {
			GameObject pawn = GameObject.Find ("Pawn (" + tl.XCoord + "," + tl.YCoord + ")");
			if (tl.Owner.GetType () == typeof(Creature)) {
				pawn_piece = (Creature)tl.Owner;
				neighbours = tl.GetNeighbours (pawn_piece.MoveStep - 1);
				HexHighligh (neighbours);
				MouseController.firstClick = true;
				/*
				if (Input.GetKey (KeyCode.Escape))
					HexReset ();
				else if (Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2)) {
					Debug.Log ("Button clicked twice");
					Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
					RaycastHit hitInfo;

					if (Physics.Raycast(ray, out hitInfo))
					{
						// ray hit something
						// we would now detect what we hit.
						GameObject hitObject = hitInfo.collider.transform.gameObject;
						// This is a hack and it is dumb, have the hex script on the top level and hard code it to trace all the way back.
						// Check if the object clicked is a type tile object.
						if (hitObject.tag == "Tile") {
							Tile destination = hitObject.transform.parent.transform.parent.GetComponent<Hex> ().tile_rep;
							if (neighbours.Contains(destination)){ 		// Indicates that this is a valid tile to move to.
								pawn_piece.Move(destination);
								pawn.transform.Translate (hitObject.transform.position);
							} else
								Debug.Log("Can't move there.");
						}
					}
				}
				*/
			} else {
				Debug.Log ("Can't move this object.");
			}
		}
	}
	void OnMoveSelected (Tile tl) {
		if (tl.Owner == null && neighbours.Contains (tl)) {
			GameObject tile = GameObject.Find ("Hex (" + tl.XCoord + "," + tl.YCoord + ")");
			// Move the player there.
			GameObject pawn_moved = GameObject.Find("Pawn (" + pawn_piece.Loc_X + "," + pawn_piece.Loc_Y + ")");
			pawn_piece.Move (tl);
			pawn_moved.transform.position = tile.transform.position;
			pawn_moved.name = "Pawn (" + pawn_piece.Loc_X + "," + pawn_piece.Loc_Y + ")";
			Debug.Log ("Move selected");
		}

		MouseController.firstClick = false;	
		HexReset ();
	}

	void HexHighligh(HashSet<Tile> targets) {
		foreach (Tile t in targets) {
			GameObject tile = GameObject.Find ("Hex (" + t.XCoord + "," + t.YCoord + ")");
			if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color == Color.white)
				tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.green;
		}
	}

	void HexReset() {
		if (neighbours != null) {
			foreach (Tile t in neighbours) {
				GameObject tile = GameObject.Find ("Hex (" + t.XCoord + "," + t.YCoord + ")");
				if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color != Color.white)
					tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.white;
			}
			neighbours.Clear ();
		}
	}
}
