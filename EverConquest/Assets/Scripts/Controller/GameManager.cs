/**
 * This class is a Game manager which will manage the events generated by other controllers in the game.
 * This is designed in accordance to the MVC pattern.
 * 
**/

using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class GameManager : MonoBehaviour {
	
	[SerializeField] private Map m_map;
	[SerializeField] private MouseController m_mouseController;

	HashSet<Tile> neighbours;
	HashSet<Tile> target_range;
	Creature pawn_piece;

	void OnEnable() {
		MouseController.OnClicked += OnHexSelected;
		MouseController.SelectMove += OnMoveSelected;
	}

	void OnDisable() {
		MouseController.OnClicked -= OnHexSelected;
		MouseController.SelectMove -= OnMoveSelected;
	}


	// Handles a onclick event generated by mouse control script when player click on top of a hex tile
	// will color a set of neighbour tiles for now.
	void OnHexSelected(Tile tl) {
		if (tl.Owner == null) {
			HexReset ();
			GameObject tile = GameObject.Find ("Hex (" + tl.XCoord + "," + tl.YCoord + ")");
			if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color == Color.white)
				tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.blue;
			else {
				tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.white;
			}

		} else {
			GameObject pawn = GameObject.Find ("Pawn (" + tl.XCoord + "," + tl.YCoord + ")");
			if (tl.Owner.GetType () == typeof(Creature)) {
				pawn_piece = (Creature)tl.Owner;
				neighbours = pawn_piece.GenerateMoves ();
				target_range = pawn_piece.GenerateRange();
				HexHighlight (neighbours, 1);
				HexHighlight (target_range, 2);
				MouseController.firstClick = true;
			} else {
				Debug.Log ("Can't move this object.");
			}
		}
	}
	void OnMoveSelected (Tile tl) {
		if (tl.Owner == null && neighbours.Contains (tl)) {
			GameObject tile = GameObject.Find ("Hex (" + tl.XCoord + "," + tl.YCoord + ")");
			// Move the player there.
			GameObject pawn_moved = GameObject.Find ("Pawn (" + pawn_piece.Loc_X + "," + pawn_piece.Loc_Y + ")");
			pawn_piece.Move (tl);
			pawn_moved.transform.position = tile.transform.position;
			pawn_moved.name = "Pawn (" + pawn_piece.Loc_X + "," + pawn_piece.Loc_Y + ")";
			Debug.Log ("Move selected");
		} else if (tl.Owner != null && pawn_piece.CheckReach(tl.Owner)) {
			// Compare the speed of two object to determine first strike, then call attack to deal with it.
			if (tl.Owner.GetType () == typeof(Creature)) {
				if (tl.Owner.Speed > pawn_piece.Speed) {
					((Creature)tl.Owner).Attack (pawn_piece);
					// Pawn retaliate if still alive.
					if (pawn_piece.Hp > 0)
						pawn_piece.Attack (tl.Owner);
				} else {
					pawn_piece.Attack (tl.Owner);
					// Opponent retaliate if still alive.
					if (tl.Owner.Hp > 0)
						((Creature)tl.Owner).Attack (pawn_piece);
				}
			} else if (tl.Owner.GetType () == typeof(Structure)) {
				pawn_piece.Attack (tl.Owner);
				// Opponent retaliate if still alive.
				if (tl.Owner.Hp > 0)
					((Structure)tl.Owner).Attack (pawn_piece);
			}
		}

		MouseController.firstClick = false;	
		HexReset ();
	}

	void HexHighlight(HashSet<Tile> targets, int flag) {
		foreach (Tile t in targets) {
			GameObject tile = GameObject.Find ("Hex (" + t.XCoord + "," + t.YCoord + ")");
			if (tile.GetComponentInChildren<MeshRenderer> () != null) {
				switch (flag) {
				case 1:
					tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.green;
					break;
				case 2:
					if (t.Owner != null && t.Owner != pawn_piece)
						tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.red;
					break;
				}
			}
		}
	}

	void HexReset() {
		if (neighbours != null) {
			foreach (Tile t in neighbours) {
				GameObject tile = GameObject.Find ("Hex (" + t.XCoord + "," + t.YCoord + ")");
				if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color != Color.white)
					tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.white;
			}
			neighbours.Clear ();
		}

		if (target_range != null) {
			foreach (Tile t in target_range) {
				GameObject tile = GameObject.Find ("Hex (" + t.XCoord + "," + t.YCoord + ")");
				if (tile.GetComponentInChildren<MeshRenderer> () != null && tile.GetComponentInChildren<MeshRenderer> ().material.color != Color.white)
					tile.GetComponentInChildren<MeshRenderer> ().material.color = Color.white;
			}
			target_range.Clear ();
		}
	}
}
